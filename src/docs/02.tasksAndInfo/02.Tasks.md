# Задачи
<br/>
<br/>

### getNumbersByParity

---

1. Реализуйте функцию getNumbersByParity, которая принимает массив чисел в качестве первого аргумента и строку "even" или "odd" в качестве второго. Функция должна вернуть новый массив, состоящий из четных чисел, если вторым аргументом было передано "even" и нечетных, если было передано "odd".
Оба аргумента функции обязательны. Первый обязательно будет массивом, а второй - строкой "even"/"odd".
    
    ```javascript
    const getNumbersByParity = (data, parity) => {
     // your code
    };
    
    const data = [1, 2, 3, 4, 5, 6];
    
    console.log(getNumbersByParity(data, 'even')); // [2, 4, 6];
    console.log(getNumbersByParity(data, 'odd')); // [1, 3, 5];`
    ```
<br/>
<br/>

### hasArrays

---

Реализуйте функцию hasArrays, которая принимает массив данных разных типов и возвращает true, если этот массив содержит массив внутри себя. Если нет, функция должна вернуть false.

```javascript
const data1 - [false, true, [1, 2], {}}, [], 1, e, NaN];
console.log(hasArrays(data1)); // true
const data2 - [];
console.log(hasArrays(data2)); // false
```
<br/>
<br/>

### moveToStart

---

Реализуйте функцию moveToStart, которая принимает массив и число п. Функция должна переставить n элементов массива из конца в начало. 
Если второй аргумент больше или равен длине массива, то должен быть возвращен новый массив, порядок элементов которого совпадает с изначальным.
Функция должна возвращать новый массив, а не мутировать старый.

```javascript
console.log(moveToStart([1, 2, 3, 4, 5], 3)); // [3, 4, 5, 1, 2]
console.log(moveToStart([1, 2, 3, 4, 5], 3)); // [3, 4, 5, 1, 2]
console.log(moveToStart([1, 2, 3, 4, 5], 10)); // [1, 2, 3, 4, 5]
```
<br/>
<br/>

### getStringCount

---

Реализуйте (с использованием рекурсии) функцию getStringCount, которая должна принимать массив или объект и считать количество строк в массиве / значениях объекта с учетом вложенности.
P.S. Для корректного прохождения проверку на рекурсию - вы должны вызывать именно функцию getStringCount

```javascript
getStringCount
({
first: '1',
second: *2
third: false,
fourth: ['anytime', 2, 3, 4 ],
fifth: null,
}); // 3

getStringCount(['1', '2', ['3']]) // 3
```
<br/>
<br/>

### sequenceSum

---

Реализуйте (с использованием рекурсии) функцию sequenceSum, которая находит сумму последовательности целых чисел.
Последовательность задается двумя значениями: 

- begin - начало последовательности,
- end - конец последовательности.
    
    Например: begin = 2 и end = 6 дают нам такую последовательность 2, 3, 4, 5, 6. Сумма такой последовательности будет: 20.
    
    ```javascript
    sequenceSum(1, 5); // 1 + 2 + 3 + 4 + 5 = 15
    sequenceSum(4, 10); // 4 + 5 + 6 + 7 + 8 + 9 + 10 = 49
    sequenceSum(-3, 2); // (-3) + (-2) + (-1) + 0 + 1 + 2 - -3
    ```
    
    Подсказки:
    
    - Последовательность, в которой begin > end, не содержит ни одного числа, т.е. является "пустой". Вычислить сумму чисел такой последовательности не представляется возможным, в этом случае возвращаем NaN
    - Сумма чисел последовательности, в которой begin === end, равна begin (или end)
    
    ```javascript
    // NaN (т.к. это "пустая" последовательность)
    sequenceSum(7, 2);
    // 0 (т.к. это единственное число, входящее в последовательность)
    sequenceSum(0, 0);
    // 6 (т.к. это единственное число, входящее в последовательность)
    sequenceSum(6, 6);
    ```
    
    P.S. Для корректного прохождения проверку на рекурсию - вы должны вызывать именно функцию sequenceSum
    
<br/>
<br/>

### **Map, рекурсия, кеш**

---

1. оптимизировать функцию getStringCount из задач на методы массивов, чтобы результат вычисления кешировался в WeakMap
2. разобраться/загуглить что такое циклическая ссылка в объекте, реализовать такой объект, разобраться почему без доработок getStringCount при наличии циклической ссылки в объекте получаем нежелательное поведение (переполнение стека вызовов), попробовать оптизимизровать решение чтобы захендлить это каким-либо образом и написать комментарий над функцией, как она работает с циклическими ссылками
3. Опционаольно, желательно после 1 и 2: исследовать как хендлит циклические ссылки метод JSON.stringify на mdn
<br/>
<br/>

### **Замыкания, ООП**

---

[Материал почитать](http://dmitrysoshnikov.com/ecmascript/javascript-the-core-2nd-edition-rus/#zamyikanie) про замыкания 
1. реализовать счетчик createCounter():
на функциональном конструкторе (ООП) и на замыканиях с общим интерфейсом: increment(), decrement(), getValue().
2. После, расширьте ваш код сущностью counterBaseValue, которая должна определять на сколько изменяется значение при increment/decrement и которую можно определить при создании и изменить на уже созданном счетчике. Старый код использования до расширения должен поддерживаться и после расширения (вызов без аргумента).

Ответить на вопросы после реализации:

- Какое значение по-умолчанию было выбрано, чтобы поддержать старый код? Почему такое?
- Какой способ дает большую инкапсуляцию? Почему?
- Опциональная задача: реализуйте логику расширения counterBaseValue в реализации на ООП с помощью наследования (сделать отдельную функцию и их соединить ее с первоначальной).
<br/>
<br/>

### **Замыкания, DOM**

---

Реализуйте функцию, которая выводит последний элемент в документе, на который был совершен клик.
Далее, попробуйте реализовать клик-стрим: решите, клик по каким элементам на странице или внутри которых вы хотели бы логировать и передавать в какой-либо сервис для статистики. Для остальных элементов такую передачу не делайте. Попробуйте писать в локальный объект и потом убедиться, что код корректно посчитал количество кликов для каждого элемента в отдельности (для этого элемента - столько, для этого - столько, для этих элементов - столько).
Опционально: Возможно вы захотите еще больше разделить статистику - попробуйте собрать данные о компе/браузере/экране юзера и включить ее в объект статистики)
<br/>
<br/>

### **Конструктор заказа. Основы. learnjs 1.1..1.4**

---

Написать функцию конструктор для заказа в магазине.

Новый инстанс - новый заказ у него будут методы:

- `addItem(item, count)` - добавить итем в чек (+ имя +цена)
- `removeItem(item, count)` - убрать из чека count итемов (если не указано сколько - убрать все). Нельзя убрать больше чем было в чеке
- `getCheck()` - получить информацию сколько каких итемов в чеке, общую цену, опционаольно цену за каждую позицию (за 3 пивка - 300р). Формат произвольный, чтобы был читабельный
- `lockOrder()` - после вызова метода функции addItem/removeItem не должны делать что-либо. Можно как-то сообщать об ошибке, можно просто молча.
- `unlockOrder()` - убрать блокировку заказа - снова можно добавлять итемы

Формат `item` - объект с:

- Названием итема;
- Ценой за штуку. Два итема с одинаковым именем считаем одной позицией в чеке.

Использовать отладку (`debugger`) при решении в хроме. Если получится без отладки - самому допустить ошибку и найти ее при отладке через интерфейс девтулзов 
<br/>
<br/>

### setTimeout/setInterval, ООП, DOM

---

1. Сделать секундомер (буквально), там есть кнопки:
старт/пауза (в зависимости включен или нет).
обнулить (если был запущен и щас пауза). Доступна только когда у нас пауза.
2. Предлагается реализовать логику на ООП: (объект/функция конструктор без разницы) и потом создать DOM представление для этой модели - добавить вывод + обновление времени в DOM и кнопки действий.
3. Таймер должен быть "точным" - отсчитывать время с запуска через Date.now() или performance.now(). Обновляться должен достаточно часто, но не обязательно раз в миллисекунду (60 fps будет достаточно)

**Опционально после реализации:** добавляется кнопка "круг" - сохраняется текущее время как запись и таймер начинается заново. Доступна только когда у нас НЕ пауза (в работе).
<br/>
<br/>

### Symbol.iterator, Деструкторизация

---

Деструктрурировать массив как объект и получить не undefined значения.
Деструктурировать объект как массив. Какая ошибка появляется? Применить Symbol.iterator чтобы деструкторизировать без ошибок.
<br/>
<br/>

### RegExp, реальные продуктовые задачи

---

1. Написать ФЛК адреса электронной почты (регулярку)
2. Написать к нему

Тесты в jest среде.

**Требования:**
Поле содержит адрес в формате: <имя почтового ящика>@<имя сервера>.<доменная зона> и содержит 320 символов (вместе с @). 
Ограничение в имени почтового ящика <имя почтового ящика> составляет не более 64 символа, в доменной зоне <имя сервера>.<доменная зона> не более 255 символов.

**Имя почтового ящика и имя сервера может содержать**: 

- Латиница или кириллица (для кириллической доменной зоны)
- Цифры
- Специальные символы: «.» точка и «-» дефис, при условии, что имя почтового ящика и имя сервера не должно:
- Начинаться и заканчиваться с точки или дефиса;
- Содержать подряд точку и дефис;
- Содержать подряд дефис и точку;
- Содержать подряд две точки;
- Содержать подряд два дефиса.

**Доменная зона может содержать**: 

- Латиница или кириллица (для кириллической доменной зоны)
<br/>
<br/>

### Кеш, методы массивов, Map

---

Добавить возможность логировать историю вызовов (натянуть на любую ООП сущность которую реализовывали - например на конструктор заказов в магазине, но не обязательно)
В чем суть: Все публичные мутирующие методы должны запоминать с чем они были вызваны - отдельно по каждому методу должна быть информация по каждому его вызову и с какими аргументами был каждый вызов.
Потом можно будет благодаря этой фиче "посмотреть логи" - когда и какой метод был вызван раз.
Нужно получить +- след результат по формату (зависит от вашей задачи):

- "08:46:10 Добавлено "Пиво" (id #10) 4 шт"
- "08:46:10 Удалено "Молоко" (id #6) 1 шт"
- "08:46:09 Добавлено "Молоко" (id #6) 2 шт"

Добавить метод в вашу сущность getLog() который будет выводить полный лог (сначала последние вызовы - ниже более старые)
<br/>
<br/>

### **ООП, глава 9**

---

Сложность 6/10 на собесе, обычно 3/10
Дан код, ответить на вопросы к нему

1. Почему одни и те же имена свойств, но не ругается интерпретатор?
2. Что такое геттеры и есть ли тут они? Что такое методы и есть ли тут они?
3. Что такое класс и экземпляр класса?
4. Куда записывается каждое свойство?
5. Что выведется в результате выполнения for и spread? Почему?

```javascript
class Item {
data = 10;
get() {}
static data = 20;
static get() {}
}
//
for (const key in Item) { log(key); }
for (const key in new Item()) { log(key); }
//
log({...new Item()});
log({...Item});
```
<br/>
<br/>

### **Главы 2, 4, 5, 8**

---

Сложность 5/10 на собесе, обычная 3/10
Реализовать функционал, чтобы работало как ожидается

```
// returns new array with these rules:
//
[1,2,3].copy(2) // [1,2,3,1,2,3]
[4].copy(3) // [4,4,4]
[1,2,3].copy(1) // [1,2,3]
[1,2,3].copy(-1) // []
[1,2,3].copy(0) // []
[1,2,3].copy() // [1,2,3]
```
<br/>
<br/>

### **Главы 9, 11**

---

1. реализовать Promise.myAny
2. реализовать метод Promise.myAll
3. реализовать Promise.anyResolved - реждектимся, только если все зареджектились, а ресолвимся, если любой заресолвился.
anyResolved будет отличаться от any тем, что принимает доп. аргумент - количество промисов, после которых ресолвится. Например, если кинуть ему 3, то будет ждать 3 заресолвивишихся и потом сразу сам заресолвит, а если 3 не получится - реджектит. Нужно сделать оптимально, чтоб когда уже 100% не хватит оставшихся промисов для ресолва, не ждать их, а сразу реджектить.
<br/>
<br/>

### Задачи на Git

---

**1 задача**

1. Изучить что такое git и зачем он нужен
2. Сделать тестовый репозиторий на `github.com`
3. Скачать его на компьютер через `git clone`
4. Закоммитить туда через `git add` и `git commit` с любым изменением в файле
5. Запушить через `git push`. Если не получится, попробовать через программу `Github Desktop`.

**2 задача**

Я создал репо [js-notes-md](https://github.com/maximumJavascript/js-notes-md)

Ваша задача:

1. Погуглить что такое `pull request` (ПР) и как сделать контрибуцию / ПР на `github` в чужой репозиторий.
2. Ознакомиться с текущими файлами в репо в ветке `develop`.
3. Написать заметку по любой теме, которую вы проходите. Использовать `obsidian.md`
4. В заметке добавить ссылку на другую заметку в формате, как сделано в заметке `Symbol.md`.
5. Кинуть ПР на этот репо **на ветку develop** с вашей заметкой. В репо есть примеры ПРов.

После выполнения задания я вас добавлю в коллабораторы репо и можно будет напрямую пушить без ПРа.

**3 задача**

1. Сверстать сайт, макет и логика по своему желанию.
Можно сделать react приложение, можно просто html css сайт.
Смысл задачи в деплое, но сайт должен быть не за 10 минут работы, а что-то, на что можно посмотреть без вытекания глаз.
Можно и желательно найти макет в `Figma` и сверстать по нему.
2. Задеплоить его с помощью github pages.

В конце каждого дня работы, когда заканчиваете, нужно пушить все изменения в репо github.
Нужно приучить себя так делать для всего кода, который пишете.
